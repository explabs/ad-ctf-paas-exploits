package runner

import (
	"fmt"
	mdb "github.com/explabs/ad-ctf-paas-api/database"
	"github.com/explabs/ad-ctf-paas-exploits/service/storage"
	log "github.com/sirupsen/logrus"
	"strconv"
)

type Message struct {
	Team  string `json:"team"`
	Round string `json:"round"`
}

func RunExploits(m *Message) error {
	round, _ := strconv.Atoi(m.Round)
	teamData, err := mdb.GetTeam(m.Team)
	if err != nil {
		return err
	}
	exploits, _ := storage.FindExploits(round)
	for _, exploit := range exploits {
		scriptPath := fmt.Sprintf("exploits/%s", exploit.Script)

		logFields := log.Fields{"team": teamData.Login,
			"service": exploit.Name,
			"script":  exploit.Script,
			"round":   m.Round,
		}

		exploitAnswer, stderr, osErr := RunScript(scriptPath, teamData.Login)
		if osErr != nil {
			log.WithFields(logFields).Error(osErr.Error())
		} else if stderr != "" {
			log.WithFields(logFields).Error(stderr)
		} else if exploitAnswer == "0" || exploitAnswer == "1" {
			score, dbErr := mdb.GetTeamsScoreboard(teamData.Login)
			if dbErr != nil {
				return dbErr
			}
			if lastService, ok := score.LastServices[exploit.Name]; ok {
				lastService.Gained = score.Services[exploit.Name].Gained
				lastService.Lost = score.Services[exploit.Name].Lost
				score.LastServices[exploit.Name] = lastService
			}

			if entry, ok := score.Services[exploit.Name]; ok {
				if exploitAnswer == "1" {
					entry.Lost += 1
					log.WithFields(logFields).Info("service exploitable")
				} else if exploitAnswer == "0" {
					entry.Gained += 1
					log.WithFields(logFields).Info("service not exploitable")
				}
				score.Services[exploit.Name] = entry
				log.Println(score)
				answer, updateErr := storage.UpdateService(exploit.Name, score)
				if updateErr != nil {
					log.Println(updateErr)
					return updateErr
				}
				log.Println(answer.ModifiedCount)
			}
		}
	}
	return nil
}
