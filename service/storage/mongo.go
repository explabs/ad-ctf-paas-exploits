package storage

import (
	"context"
	"fmt"
	"github.com/explabs/ad-ctf-paas-api/models"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"gopkg.in/yaml.v3"
	"io/ioutil"
	"log"
	"os"
	"strconv"
	"strings"
)

type Exploits struct {
	Exploits []YamlExploit `json:"exploits"`
}

func (e *Exploits) Load() {
	yamlFile, err := ioutil.ReadFile("config.yml")
	if err != nil {
		panic(err)
	}
	err = yaml.Unmarshal(yamlFile, &e)
	if err != nil {
		panic(err)
	}
}

type YamlExploit struct {
	Name   string      `yaml:"name"`
	Script string      `yaml:"script"`
	Rounds interface{} `yaml:"rounds"`
}

type Exploit struct {
	Name   string `bson:"name" json:"name"`
	Script string `bson:"script" json:"script"`
	Rounds []int  `bson:"round" json:"round"`
}

func getMongoClient() (*mongo.Client, error) {
	credential := options.Credential{
		Username: "admin",
		Password: os.Getenv("ADMIN_PASS"),
	}
	var host, port = "mongo", 27017
	if os.Getenv("MODE") == "dev" {
		host = "localhost"
	}
	mongoURI := fmt.Sprintf("mongodb://%s:%d", host, port)
	clientOpts := options.Client().ApplyURI(mongoURI).SetAuth(credential)
	return mongo.Connect(context.TODO(), clientOpts)
}
func collection() (*mongo.Collection, error) {
	client, err := getMongoClient()
	if err != nil {
		return nil, err
	}
	coll := client.Database("ad").Collection("scoreboard")
	return coll, nil
}

func exploitCollection() (*mongo.Collection, error) {
	client, err := getMongoClient()
	if err != nil {
		return nil, err
	}
	coll := client.Database("ad").Collection("exploits")
	return coll, nil
}

func UpdateService(score models.Score) (*mongo.UpdateResult, error) {
	coll, err := collection()
	if err != nil {
		log.Fatal(err)
	}
	filter := bson.M{"name": score.Name}
	update := bson.M{
		"$set": score,
	}
	return coll.UpdateOne(context.Background(), filter, update)
}
func makeRange(min, max int) []int {
	a := make([]int, max-min+1)
	for i := range a {
		a[i] = min + i
	}
	return a
}

func InArray(array []int, element int) bool {
	for _, elem := range array {
		if elem == element {
			return true
		}
	}
	return false
}

func union(result []int, array []int) []int {
	for _, elem := range array {
		if !InArray(result, elem) {
			result = append(result, elem)
		}
	}
	return result
}

func (e *YamlExploit) convert() Exploit {
	exploit := Exploit{Name: e.Name, Script: e.Script}
	switch e.Rounds.(type) {
	case int:
		exploit.Rounds = []int{e.Rounds.(int)}
	case []int:
		exploit.Rounds = e.Rounds.([]int)
	case string:
		var roundsArray []int
		rounds := strings.Split(e.Rounds.(string), ",")
		for _, roundStr := range rounds {
			intRounds := strings.Split(roundStr, "-")
			if len(intRounds) == 2 {
				start, err := strconv.Atoi(intRounds[0])
				if err != nil {
					return Exploit{}
				}
				end, err := strconv.Atoi(intRounds[1])
				if err != nil {
					return Exploit{}
				}
				if end > start {
					roundsArray = union(roundsArray, makeRange(start, end))
				}
			}
		}
		exploit.Rounds = roundsArray
	}
	return exploit
}
func (e *Exploits) UploadExploit() error {
	coll, err := exploitCollection()
	if err != nil {
		log.Fatal(err)
	}
	var exploits []interface{}

	for _, exploit := range e.Exploits {
		exploits = append(exploits, exploit.convert())
	}

	coll.DeleteMany(context.Background(), bson.M{})
	_, err = coll.InsertMany(context.Background(), exploits)
	if err != nil {
		log.Println(err)
	}
	return nil
}

func FindExploits(round int) ([]Exploit, error) {
	coll, err := exploitCollection()
	if err != nil {
		log.Fatal(err)
	}
	cur, err := coll.Find(context.TODO(), bson.M{"round": round})
	if err != nil {
		log.Fatal(err)
	}
	//Finding multiple documents returns a cursor
	//Iterate through the cursor allows us to decode documents one at a time

	var results []Exploit

	for cur.Next(context.TODO()) {
		//Create a value into which the single document can be decoded
		var e Exploit
		err := cur.Decode(&e)
		if err != nil {
			log.Fatal(err)
		}

		results = append(results, e)

	}

	if err := cur.Err(); err != nil {
		log.Fatal(err)
	}

	//Close the cursor once finished
	cur.Close(context.TODO())
	return results, nil
}
